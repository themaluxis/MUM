<!-- Admin Streaming Activity Chart -->
<div class="card bg-base-200 shadow-xl">
    <div class="card-body">
        <!-- Chart Header -->
        <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-6">
            <div>
                <h2 class="card-title text-xl mb-2">
                    <i class="fa-solid fa-chart-bar text-primary"></i>
                    Streaming Activity
                </h2>
                <p class="text-sm text-base-content/70">
                    Total activity across all users and services
                </p>
            </div>
            
            <!-- Time Range Selector -->
            <div class="flex flex-wrap gap-2 mt-4 sm:mt-0">
                <a href="{{ url_for('dashboard.index', days=7) }}" 
                   class="btn btn-sm {{ 'btn-primary' if selected_days == 7 else 'btn-outline' }}">
                    7 Days
                </a>
                <a href="{{ url_for('dashboard.index', days=30) }}" 
                   class="btn btn-sm {{ 'btn-primary' if selected_days == 30 else 'btn-outline' }}">
                    30 Days
                </a>
                <a href="{{ url_for('dashboard.index', days=90) }}" 
                   class="btn btn-sm {{ 'btn-primary' if selected_days == 90 else 'btn-outline' }}">
                    90 Days
                </a>
            </div>
        </div>

        <!-- Chart Container -->
        <div class="relative h-80 mb-6">
            <canvas id="adminStreamingChart"></canvas>
        </div>

        <!-- Chart Stats -->
        <div class="grid grid-cols-1 sm:grid-cols-3 gap-4 mb-4">
            <div class="stat bg-base-100 rounded-lg p-4">
                <div class="stat-title text-xs">Total Streams</div>
                <div class="stat-value text-lg">{{ chart_data.total_streams }}</div>
            </div>
            <div class="stat bg-base-100 rounded-lg p-4">
                <div class="stat-title text-xs">Total Duration</div>
                <div class="stat-value text-lg">{{ chart_data.total_duration }}</div>
            </div>
            <div class="stat bg-base-100 rounded-lg p-4">
                <div class="stat-title text-xs">Most Active Service</div>
                <div class="stat-value text-lg">{{ chart_data.most_active_service }}</div>
            </div>
        </div>

        <!-- Service Legend - Hidden on mobile for more chart space -->
        {% if chart_data.services %}
        <div class="border-t border-base-300 pt-4 hidden sm:block">
            <h3 class="text-sm font-semibold mb-3">Services</h3>
            <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3">
                {% for service in chart_data.services %}
                <div class="flex items-center gap-3 p-2 bg-base-100 rounded-lg">
                    <div class="w-4 h-4 rounded" style="background-color: {{ service.color }}"></div>
                    <div class="flex-1 min-w-0">
                        <div class="text-sm font-medium">{{ service.name }}</div>
                        <div class="text-xs text-base-content/70">
                            {{ service.watch_time }} â€¢ {{ service.count }} streams
                        </div>
                    </div>
                </div>
                {% endfor %}
            </div>
        </div>
        {% endif %}
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const ctx = document.getElementById('adminStreamingChart').getContext('2d');
    
    // Chart data from backend
    const chartData = {{ chart_data.chart_data | tojson | safe }};
    const services = {{ chart_data.services | tojson | safe }};
    
    if (!chartData || chartData.length === 0) {
        // Show "No data" message
        ctx.font = '16px Arial';
        ctx.fillStyle = '#666';
        ctx.textAlign = 'center';
        ctx.fillText('No streaming data available', ctx.canvas.width / 2, ctx.canvas.height / 2);
        return;
    }
    
    // Helper function to convert hex to rgba for opacity
    const hexToRgba = (hex, alpha) => {
        const r = parseInt(hex.substr(1, 2), 16);
        const g = parseInt(hex.substr(3, 2), 16);
        const b = parseInt(hex.substr(5, 2), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    };

    // Prepare datasets for stacked bar chart
    const datasets = [];
    
    // Create a dataset for each service
    services.forEach(service => {
        const data = chartData.map(point => point[service.type] || 0);
        
        datasets.push({
            label: service.name,
            data: data,
            backgroundColor: service.color,
            borderColor: service.color,
            borderWidth: 1,
            stack: 'stack1', // All services stack in the same column
            _serviceType: service.type // Store service type for hover effect
        });
    });
    
    // Chart configuration
    const config = {
        type: 'bar',
        data: {
            labels: chartData.map(point => point.label),
            datasets: datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            onHover: (event, activeElements, chart) => {
                if (activeElements.length > 0) {
                    const { datasetIndex } = activeElements[0].element.$context;
                    const hoveredDataset = chart.data.datasets[datasetIndex];
                    const hoveredServiceType = hoveredDataset._serviceType;

                    // Set all datasets to 30% opacity except the hovered one
                    chart.data.datasets.forEach(dataset => {
                        const serviceType = dataset._serviceType;
                        const baseColor = services.find(s => s.type === serviceType)?.color || '#64748b';
                        
                        // Ensure backgroundColor and borderColor are arrays
                        if (!Array.isArray(dataset.backgroundColor)) {
                            dataset.backgroundColor = new Array(dataset.data.length).fill(baseColor);
                        }
                        if (!Array.isArray(dataset.borderColor)) {
                            dataset.borderColor = new Array(dataset.data.length).fill(baseColor);
                        }

                        // Set opacity based on whether this service matches the hovered one
                        const opacity = (serviceType === hoveredServiceType) ? 1.0 : 0.3;
                        const color = hexToRgba(baseColor, opacity);
                        
                        for (let i = 0; i < dataset.data.length; i++) {
                            dataset.backgroundColor[i] = color;
                            dataset.borderColor[i] = color;
                        }
                    });
                } else {
                    // Reset all to 100% opacity when not hovering
                    chart.data.datasets.forEach(dataset => {
                        const serviceType = dataset._serviceType;
                        const baseColor = services.find(s => s.type === serviceType)?.color || '#64748b';
                        
                        for (let i = 0; i < dataset.data.length; i++) {
                            dataset.backgroundColor[i] = baseColor;
                            dataset.borderColor[i] = baseColor;
                        }
                    });
                }
                chart.update(); // Update the chart to reflect color changes
            },
            interaction: {
                mode: 'nearest',
                intersect: true
            },
            plugins: {
                title: {
                    display: false
                },
                legend: {
                    display: false // We have our own legend below
                },
                tooltip: {
                    callbacks: {
                        title: function(context) {
                            return context[0].label;
                        },
                        label: function(context) {
                            const serviceName = context.dataset.label;
                            const minutes = context.parsed.y;
                            
                            if (minutes === 0) return null;
                            
                            // Convert minutes to hours and minutes for display
                            const hours = Math.floor(minutes / 60);
                            const remainingMinutes = Math.round(minutes % 60);
                            
                            let timeStr = '';
                            if (hours > 0) {
                                timeStr = `${hours}h ${remainingMinutes}m`;
                            } else {
                                timeStr = `${remainingMinutes}m`;
                            }
                            
                            return `${serviceName}: ${timeStr}`;
                        },
                        footer: function(context) {
                            // Calculate total for this day
                            const total = context.reduce((sum, item) => sum + item.parsed.y, 0);
                            const hours = Math.floor(total / 60);
                            const minutes = Math.round(total % 60);
                            
                            let totalStr = '';
                            if (hours > 0) {
                                totalStr = `${hours}h ${minutes}m`;
                            } else {
                                totalStr = `${minutes}m`;
                            }
                            
                            return `Total: ${totalStr}`;
                        }
                    },
                    filter: function(tooltipItem) {
                        return tooltipItem.parsed.y > 0; // Only show non-zero values
                    }
                }
            },
            scales: {
                x: {
                    stacked: true,
                    grid: {
                        display: false
                    }
                },
                y: {
                    stacked: true,
                    beginAtZero: true,
                    title: {
                        display: window.innerWidth >= 640, // Hide on mobile (< 640px)
                        text: 'Watch Time (minutes)'
                    },
                    ticks: {
                        callback: function(value) {
                            // Convert minutes to hours for y-axis labels
                            if (value >= 60) {
                                const hours = Math.floor(value / 60);
                                const minutes = value % 60;
                                return minutes > 0 ? `${hours}h ${minutes}m` : `${hours}h`;
                            }
                            return `${value}m`;
                        }
                    }
                }
            }
        }
    };
    
    // Create the chart
    new Chart(ctx, config);
});
</script>